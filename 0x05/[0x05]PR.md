# [Chapter이름 (0x05)] 강의 및 문제풀이 완료

## 📅 학습 기간

- **기간**: 2025.09.16 ~ 2025.09.26
- **학습 시간**:
  - 화 / 20m? / 10828번
  - 수 / 5m / 10773번
  - 산프 이슈로 짬짬히 해서 시간 체크 못함
  - PR도 10/2일에 작성함 ㅋㅋ

---

## 💡 주요 문제 상세 풀이

### 📝 문제 1: [백준 10828] 스택

#### 🎯 문제

정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.

명령은 총 다섯 가지이다.

- push X: 정수 X를 스택에 넣는 연산이다.
- pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.
- size: 스택에 들어있는 정수의 개수를 출력한다.
- empty: 스택이 비어있으면 1, 아니면 0을 출력한다.
- top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.

- **입력**: 첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다. 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다. 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다. 문제에 나와있지 않은 명령이 주어지는 경우는 없다.
- **출력**: 출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.

#### 🔍 접근 과정

1. stack class 만들고 switch case로 입력값에 따라 constructor로 생성된 메서드들로 처리해주기.
   1.1. 항상 JS 풀때 공백 구분으로 입력값 처리가 넘 어려움 push가 제대로 안됨

**1차 시도 (실패)**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let lineCnt = 0;
let n = 0;

class Stack {
  constructor() {
    this._arr = [];
  }
  push(data) {
    this._arr.push(data);
  }
  pop() {
    let res = this._arr.pop();
    if (res == undefined) return -1;
    else return Number(this._arr.pop());
  }
  top() {
    if (this._arr[this._arr.length - 1] == undefined) return -1;
    else return Number(this._arr[this._arr.length - 1]);
  }
  empty() {
    if (this._arr.length == 0) return 1;
    else return 0;
  }
}

let stack = new Stack();

rl.on('line', (line) => {
  if (lineCnt === 0) {
    n = Number(line);
    console.log(n);
    lineCnt++;
  } else {
    switch (line.split(' ')[0]) {
      case 'push':
        stack.push(Number(line.split(' ')[1]));
        lineCnt++;
        break;
      case 'pop':
        console.log(Number(stack.pop()));
        lineCnt++;
        break;
      case 'size':
        console.log(Number(stack._arr.length));
        lineCnt++;
        break;
      case 'empty':
        console.log(Number(stack.empty()));
        lineCnt++;
        break;
      case 'top':
        console.log(Number(stack.top()));
        lineCnt++;
        break;
    }
    if (lineCnt === n) {
      rl.close();
    }
  }
}).on('close', () => {
  process.exit();
});
```

**실패 이유(실패한 경우에만)**

- line이 14입력받고 사실 14 + 1이어야해서 close 조건을 n+1로 수정
- 예시 입력 잘 되는데 왜 틀렸지
- pop 두번 호출하는 오류 있었음
  ```js
  pop() {
  let res = this.\_arr.pop(); // (1) 여기서 pop이 한 번 호출됩니다.
  if (res == undefined) return -1;
  else return Number(this.\_arr.pop()); // (2) 그런데 여기서 pop이 또 호출되네요?
  }
  ```
- size도 stack class 내부에 넣어서 메서드로 만들어서 쓰자
  ```js
  res.push(Number(stack.\_arr.length)); -> size() {
  return Number(stack.\_arr.length);
  }
  ```
  여기서 아래와 같이 변경
  ```js
  size() {
    return Number(stack._arr.length);
  }
  ```

**최종 코드**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let lineCnt = 0;
let n = 0;
let res = [];

class Stack {
  constructor() {
    this._arr = [];
  }
  push(data) {
    this._arr.push(data);
  }
  pop() {
    let res = this._arr.pop();
    if (res == undefined) return -1;
    else return Number(res);
  }
  top() {
    if (this._arr[this._arr.length - 1] == undefined) return -1;
    else return Number(this._arr[this._arr.length - 1]);
  }
  empty() {
    if (this._arr.length == 0) return 1;
    else return 0;
  }
  size() {
    return Number(stack._arr.length);
  }
}

let stack = new Stack();

rl.on('line', (line) => {
  if (lineCnt === 0) {
    n = Number(line);
    lineCnt++;
  } else {
    switch (line.split(' ')[0]) {
      case 'push':
        stack.push(Number(line.split(' ')[1]));
        lineCnt++;
        break;
      case 'pop':
        res.push(stack.pop());
        lineCnt++;
        break;
      case 'size':
        res.push(stack.size());
        lineCnt++;
        break;
      case 'empty':
        res.push(stack.empty());
        lineCnt++;
        break;
      case 'top':
        res.push(stack.top());
        lineCnt++;
        break;
    }
    if (lineCnt === n + 1) {
      rl.close();
    }
  }
}).on('close', () => {
  console.log(res.join('\n'));
  process.exit();
});
```

#### 💭 배운 점

- 스택 복습 겸 코드 구현

#### 참고 자료

- https://helloworldjavascript.net/pages/282-data-structures.html#%EC%8A%A4%ED%83%9D-stack

---

### 📝 문제 2: [백준 10773] 제로

#### 🎯 문제

나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.

재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.

재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.

재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!

- **입력**: 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)

이후 K개의 줄에 정수가 1개씩 주어진다. 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 "0" 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.

정수가 "0"일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.

- **출력**: 재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다.

#### 🔍 접근 과정

1. 0이 아닌 수 입력되면 배열에 push
2. 0이 입력되면 배열에서 pop
3. 입력이 종료되면 배열 요소의 합을 console.log

**최종 코드**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let lineCnt = 0;
let n = 0;
let res = [];

rl.on('line', (line) => {
  if (lineCnt === 0) {
    n = Number(line);
    lineCnt++;
  } else {
    if (line == '0') {
      res.pop();
      lineCnt++;
    } else {
      res.push(Number(line));
      lineCnt++;
    }

    if (lineCnt === n + 1) {
      rl.close();
    }
  }
}).on('close', () => {
  let sum = 0;
  if (res.length == 0) {
    console.log(sum);
  } else {
    for (let i = 0; i < res.length; i++) {
      sum += res[i];
    }
    console.log(sum);
  }

  process.exit();
});
```

#### 💭 배운 점

- 5분컷. 이지피지. 그냥 간단하게 입력에서는 0이 입력되면 pop해주고, 마지막에 배열 요소의 합 출력해주면됨
  type 잘 체크해서 품

#### 참고 자료

- X

---

### 📝 문제 3: [백준 1874] 스택 수열

#### 🎯 문제

스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.

1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라.

- **입력**: 첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다.
- **출력**: 입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다.

#### 🔍 접근 과정

1. 스택에 1부터 넣다가 입력값과 마주치면 pop!
   1.1 넣다가 스택의 Top이 입력값[i]와 같으면 pop함
2. 입력값 저장할 배열, 스택 이렇게 2개 필요함

**최종 코드(한번에 성공한 코드 위 1차시도 skip 후 최종코드 부터 작성)**

```javascript
rl.on('line', (line) => {
  input.push(line);
}).on('close', () => {
  const n = Number(input[0]);
  const targetArr = input.slice(1).map(Number);

  const stack = [];
  const res = []; // '+'와 '-' 연산을 저장할 배열
  let currentNum = 1; // 1부터 n까지 오름차순으로 스택에 push될 숫자

  for (let i = 0; i < n; i++) {
    const target = targetArr[i];

    // 현재 push할 숫자가 만들어야 할 target 값보다 작거나 같으면 스택에 push
    while (currentNum <= target) {
      stack.push(currentNum);
      res.push('+');
      currentNum++;
    }

    // PUSH 단계가 끝난 후, 스택의 맨 위 값이 target과 일치하는지 확인합니다.
    const popped = stack.pop(); // 스택에서 값을 하나 꺼냅니다.

    // 꺼낸 값이 target과 다르다면, NO
    if (popped !== target) {
      console.log('NO');
      process.exit();
    }
    res.push('-');
  }

  // 모두 실행되었다면, 수열 생성이 가능한 경우니까 결과 출력
  console.log(res.join('\n'));

  process.exit();
});
```

#### 💭 배운 점

-
-

#### 참고 자료

- 혹시 메서드나 알고리즘 등의 아이디어를 얻기 위해 참고한 블로그, 공식문서 등등

---

### 📝 문제 4: [백준 2493] 탑

#### 🎯 문제

KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.

예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.

탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.

- **입력**: 첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.
- **출력**: 첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.

#### 🔍 접근 과정

1. 신호탑의 왼쪽에서 신호탑보다 높은 탑이 받는다.
   1.1. ex) [6, 9, 5, 7, 4] 라는 input이 들어오면 <- 쪽으로 신호를 날리니까.

2. 4의 신호는 7이 받고
   7은 9가 받고 (5는 7보다 낮으니 7의 신호를 못받음)
   5의 신호는 9가 받고
   9의 신호는 아무도 못받고
   6의 신호도 아무도 못받는다.

3. input[i]의 신호는 input[i-1 to 0]까지 애들 중 first로 input[i]보다 큰 index가 받는다.
   let i = 0
   for (let j = 배열 길이; j >= 0; j--)
   let res = 0;  
   input[j] =< input[i]
   res = j
   if (아무것도 못받음) 0

**1차 시도 (실패/성공)**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let n = 0;
let lineCnt = 0;

rl.on('line', (line) => {
  const res = [];

  if (lineCnt === 0) {
    n = Number(line);
    lineCnt++;
  } else {
    let inputs = line.split(' ').map(Number);
    let currentTop = n - 1;

    while (currentTop != -1) {
      for (let i = currentTop - 1; i >= -1; i--) {
        if (inputs[currentTop] == inputs[i] || inputs[currentTop] < inputs[i]) {
          res[currentTop] = i + 1;
          break;
        } else {
          res[currentTop] = 0;
        }
      }
      currentTop--;
    }

    console.log(res.join(' '));
    rl.close();
  }
}).on('close', () => {
  process.exit();
});
```

**실패 이유(실패한 경우에만)**

- 아마 스택 안쓰고 배열기반으로해서 시간초과 나온 것 같음
- 그렇다면 스택을 어떻게 이 문제에 활용할까.

1. input 값을 stack에 넣음
2. 첫 번쨰 pop한게 첫 번째로 신호를 보내는 탑임
   2.1. stack 에서 pop()한 결과
3. 그 값과 스택을 순회하며? (pop하며? 근데 pop하면 다시 넣어야하니까 peek로?) 2의 결과보다 작은 값을 찾으면 됨
   3.1. 그러면 index 변수가 필요하려나

**최종 코드(한번에 성공한 코드 위 1차시도 skip 후 최종코드 부터 작성)**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let n = 0;
let lineCnt = 0;

rl.on('line', (line) => {
  if (lineCnt === 0) {
    n = Number(line);
    lineCnt++;
  } else {
    let inputs = line.split(' ').map(Number);
    let n = inputs.length;
    const res = new Array(n).fill(0);
    const stack = [];

    for (let i = 0; i < n; i++) {
      while (stack.length > 0 && inputs[stack[stack.length - 1]] < inputs[i]) {
        stack.pop();
      }

      if (stack.length > 0) {
        res[i] = stack[stack.length - 1] + 1;
      }

      stack.push(i);
    }

    console.log(res.join(' '));
    rl.close();
  }
}).on('close', () => {
  process.exit();
});
```

#### 💭 배운 점

- 50만 이상정도 되면 배열로 풀어서 O(n^2) 시간복잡도가 되면 시간초과가 나온다 (1.5초 기준)
- 배열이 아니라 스택 기반으로 문제를 풀이를 자연스럽게 바꾸는 시도를 해야겠다.

#### 참고 자료

---

## 📈 이번 주차 복기

### 🔄 이전 주차 대비 개선점

- 문제 인식? 어떤 것을 해야하는지는 이제 잘 이해하는듯.
- 그런데 아직도 시간 복잡도 생각해서 이걸 배열로 처리하면 시간 초과 터지니까 어떤 자료구조를 써야지 이거는 부족하다.
- 아오 산프 진짜 내 공부를 못하네

---
