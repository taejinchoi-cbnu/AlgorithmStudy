# [0x04] 강의 및 문제풀이 완료

## 📅 학습 기간

- **기간**: 2025.09.04 ~ 2025.09.16
- ## **학습 시간 / 내용**:
  - 04: 30m?
  - 09: 28m / 5397 문제풀이
  - 해커톤 이슈로 제대로 된 시간 측정 x

---

## 💡 주요 문제 상세 풀이

### 📝 문제 1: [백준 1406] 에디터

#### 🎯 문제

한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.

이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.

이 편집기가 지원하는 명령어는 다음과 같다.

```bash
L 커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)
D 커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)
B 커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨)
삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임
P $ $라는 문자를 커서 왼쪽에 추가함
```

초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.

- **입력**:첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.
- **출력**:첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.

#### 🔍 접근 과정

1. 첫째 줄 string, 둘째 줄 입력할 명령어 수 M, 3 to M까지 명령어 입력
2. 입력값 setting 완료 3m
3. 명령어 배열에 저장하지 말고 line에서 입력 받고 바로 실행하고 close에서는 답만 출력해주자. 3m
   3.1 string 끝에 추가해야하는데 그러면 input string을 string이 아니라 array로 처리해야하나?

**1차 시도 (실패)**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let string = [];
let lineCnt = 0;
let m = 0;

rl.on('line', (line) => {
  if (lineCnt === 0) {
    string.push(...line.split(''));
  } else if (lineCnt === 1) {
    m = Number(line);
  } else if (lineCnt <= m + 1) {
    let cursor = Number(string.length) - 1;
    switch (line[0]) {
      case 'L':
        if (cursor !== 0) {
          cursor--;
          break;
        } else break;
      case 'D':
        if (cursor !== Number(string.length)) {
          cursor++;
          break;
        } else break;
      case 'B':
        if (cursor !== 0) {
          string[cursor] = ' ';
          break;
        }
      case 'P':
        cursor++;
        string[cursor] = line[2];
        break;
    }
    if (lineCnt === m + 1) {
      rl.close();
    }
  }

  lineCnt++;
}).on('close', () => {
  console.log(string.join(''));

  process.exit();
});
```

**실패 이유(실패한 경우에만)**

- 잘 작동하는 듯 하지만 출력 초과가 나옴. n이 늘어나는 경우에서 뭔가 문제가 발생하는듯
- 배열 기반이 아니라 연결 리스트/스택으로 풀어야함
- 연결리스트로 풀어보기

**최종 코드**

```javascript
let lineCnt = 0;
let m = 0;
let head = null;
let tail = null;
let cursor = null; // cursor는 커서 바로 왼쪽에 있는 문자를 가리킴. null이면 맨 앞

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}

// 초기 문자열을 이중 연결 리스트로 변환
function initializeString(line) {
  for (let i = 0; i < line.length; i++) {
    let newNode = new Node(line[i]);

    if (head === null) {
      head = newNode;
      tail = newNode;
    } else {
      tail.next = newNode;
      newNode.prev = tail;
      tail = newNode;
    }
  }
  // 커서는 문장의 맨 뒤에 위치 (tail을 가리킴)
  cursor = tail;
}

// L: 커서를 왼쪽으로 한 칸 이동
function moveLeft() {
  if (cursor !== null) {
    cursor = cursor.prev;
  }
}

// D: 커서를 오른쪽으로 한 칸 이동
function moveRight() {
  if (cursor === null) {
    // 맨 앞에서 오른쪽으로 이동
    cursor = head;
  } else if (cursor.next !== null) {
    cursor = cursor.next;
  }
}

// B: 커서 왼쪽 문자 삭제
function deleteLeft() {
  if (cursor === null) return; // 맨 앞이면 무시

  let nodeToDelete = cursor;

  // 커서를 왼쪽으로 이동
  cursor = cursor.prev;

  // 노드 연결 수정
  if (nodeToDelete.prev !== null) {
    nodeToDelete.prev.next = nodeToDelete.next;
  } else {
    head = nodeToDelete.next;
  }

  if (nodeToDelete.next !== null) {
    nodeToDelete.next.prev = nodeToDelete.prev;
  } else {
    tail = nodeToDelete.prev;
  }
}

// P: 커서 왼쪽에 문자 추가
function insertChar(char) {
  let newNode = new Node(char);

  if (cursor === null) {
    // 맨 앞에 삽입
    if (head === null) {
      head = tail = newNode;
    } else {
      newNode.next = head;
      head.prev = newNode;
      head = newNode;
    }
  } else {
    // cursor 오른쪽에 삽입
    newNode.next = cursor.next;
    newNode.prev = cursor;

    if (cursor.next !== null) {
      cursor.next.prev = newNode;
    } else {
      tail = newNode;
    }

    cursor.next = newNode;
  }

  // 커서를 새로 삽입한 문자로 이동
  cursor = newNode;
}

// 명령어 처리
function processCommand(line) {
  const command = line[0];

  switch (command) {
    case 'L':
      moveLeft();
      break;
    case 'D':
      moveRight();
      break;
    case 'B':
      deleteLeft();
      break;
    case 'P':
      insertChar(line[2]);
      break;
  }
}

// 결과 출력
function printResult() {
  let result = '';
  let current = head;

  while (current !== null) {
    result += current.data;
    current = current.next;
  }

  console.log(result);
}

rl.on('line', (line) => {
  if (lineCnt === 0) {
    // 초기 문자열 처리
    if (line.length > 0) {
      initializeString(line);
    }
  } else if (lineCnt === 1) {
    // 명령어 개수 저장
    m = Number(line);
  } else if (lineCnt >= 2 && lineCnt <= m + 1) {
    // 명령어 처리
    processCommand(line);
  }

  lineCnt++;

  // 모든 명령어 처리 완료시 종료
  if (lineCnt > m + 1) {
    rl.close();
  }
}).on('close', () => {
  printResult();
  process.exit();
});
```

#### 최적화 시도

X

**최적화 코드**
X

**최적화 결과**
X

#### 💭 배운 점

- 입력값 범위 체크하고 O(n)으로 풀어도 되는지 O(n^2)으로도 괜찮은지 아니면 O(1)로 풀어야하는지 체크하고 문제를 풀어야겠다.
- 그냥 생각없이 배열 기반으로 풀면 시간초과, 출력 초과 등등이 나옴

#### 참고 자료

- 1일 이상 고민 후 (사실 안하긴 함) Claude와 함께 문제 풀이

---

### 📝 문제 2: [백준 5397] 키로거

#### 🎯 문제

창영이는 강산이의 비밀번호를 훔치기 위해서 강산이가 사용하는 컴퓨터에 키로거를 설치했다. 며칠을 기다린 끝에 창영이는 강산이가 비밀번호 창에 입력하는 글자를 얻어냈다.

키로거는 사용자가 키보드를 누른 명령을 모두 기록한다. 따라서, 강산이가 비밀번호를 입력할 때, 화살표나 백스페이스를 입력해도 정확한 비밀번호를 알아낼 수 있다.

강산이가 비밀번호 창에서 입력한 키가 주어졌을 때, 강산이의 비밀번호를 알아내는 프로그램을 작성하시오. 강산이는 키보드로 입력한 키는 알파벳 대문자, 소문자, 숫자, 백스페이스, 화살표이다.

- **입력**:
  첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한줄로 이루어져 있고, 강산이가 입력한 순서대로 길이가 L인 문자열이 주어진다. (1 ≤ L ≤ 1,000,000) 강산이가 백스페이스를 입력했다면, '-'가 주어진다. 이때 커서의 바로 앞에 글자가 존재한다면, 그 글자를 지운다. 화살표의 입력은 '<'와 '>'로 주어진다. 이때는 커서의 위치를 움직일 수 있다면, 왼쪽 또는 오른쪽으로 1만큼 움직인다. 나머지 문자는 비밀번호의 일부이다. 물론, 나중에 백스페이스를 통해서 지울 수는 있다. 만약 커서의 위치가 줄의 마지막이 아니라면, 커서 및 커서 오른쪽에 있는 모든 문자는 오른쪽으로 한 칸 이동한다.
- **출력**:
  각 테스트 케이스에 대해서, 강산이의 비밀번호를 출력한다. 비밀번호의 길이는 항상 0보다 크다.

#### 🔍 접근 과정

이전 문제와 비슷하다.

1. n 입력받고
2. 입력받은 line을 [i]로 돌리면서 커멘드 체크
3. res 출력?
4. 다만 이 문제는 커멘드가 아닌 문자인 경우에 연결리스트에 삽입하고, 커서는 계속 움직임

**최종 코드**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let lineCnt = 0;
let head = null;
let tail = null;
let cursor = null;
let n = 0;

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
    this.prev = null;
  }
}

// <가 입력된 경우
function moveLeft() {
  if (cursor !== null) {
    cursor = cursor.prev;
  }
}

// >가 입력된 경우
function moveRight() {
  if (cursor === null) {
    cursor = head;
  } else if (cursor.next !== null) {
    cursor = cursor.next;
  }
}

// -가 입력된 경우
function deleteNode() {
  if (cursor === null) return; // 맨 앞이면 무시

  let nodeToDelete = cursor;

  // 커서를 왼쪽으로 이동
  cursor = cursor.prev;

  // 노드 연결 수정
  if (nodeToDelete.prev !== null) {
    nodeToDelete.prev.next = nodeToDelete.next;
  } else {
    head = nodeToDelete.next;
  }

  if (nodeToDelete.next !== null) {
    nodeToDelete.next.prev = nodeToDelete.prev;
  } else {
    tail = nodeToDelete.prev;
  }
}

// 그냥 문자열이 입력된 경우
function insertNode(data) {
  let newNode = new Node(data);

  if (cursor === null) {
    // 맨 앞에 삽입
    if (head === null) {
      head = tail = newNode;
    } else {
      newNode.next = head;
      head.prev = newNode;
      head = newNode;
    }
  } else {
    // cursor 오른쪽에 삽입
    newNode.next = cursor.next;
    newNode.prev = cursor;

    if (cursor.next !== null) {
      cursor.next.prev = newNode;
    } else {
      tail = newNode;
    }

    cursor.next = newNode;
  }

  // 커서를 새로 삽입한 문자로 이동
  cursor = newNode;
}

rl.on('line', (line) => {
  if (lineCnt === 0) {
    n = Number(line);
  } else {
    let testCase = line;
    head = null;
    tail = null;
    cursor = null;

    for (let x of testCase) {
      switch (x) {
        case '<':
          moveLeft();
          break;
        case '>':
          moveRight();
          break;
        case '-':
          deleteNode();
          break;
        default:
          insertNode(x);
          break;
      }
    }
    let result = '';
    let current = head;

    while (current !== null) {
      result += current.data;
      current = current.next;
    }

    console.log(result);

    if (lineCnt === n + 1) {
      rl.close();
    }
  }
  lineCnt++;
}).on('close', () => {
  process.exit();
});
```

#### 💭 배운 점

- 연결리스트 이제 좀 이해한듯

---

### 📝 문제 3: [백준 1185] 요세푸스 문제

#### 🎯 문제

요세푸스 문제는 다음과 같다.

1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 <3, 6, 2, 7, 5, 1, 4>이다.

N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오.

- **입력**: 첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000)

- **출력**: 예제와 같이 요세푸스 순열을 출력한다.

#### 🔍 접근 과정

- 원형 큐인가? -> 원형 연결 리스트?로 가능할듯

0. N개의 원소를 원형 큐로 만들고 K만큼 next를 제거한다?
1. N K 입력
2. 1부터 N까지의 연속된 자연수로 이루어진 원형 큐 생성
3. 원형 큐에서 1부터 next (한바퀴 돈 경우 생각) 제거하고 제거한 것들을 res 배열 혹은 변수에 넣기

**1차 시도 (성공)**

```javascript
const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

let head = null;
let tail = null;
let cursor = null;
let prev = null;
let res = [];

class Node {
  constructor(data) {
    this.data = data;
    this.next = null;
  }
}

function initCircle(n) {
  for (let i = 0; i < n; i++) {
    let newNode = new Node(Number(i + 1));

    if (head === null) {
      head = newNode;
      tail = newNode;
    } else {
      tail.next = newNode;
      tail = newNode;
    }
  }
  tail.next = head;
  // 커서는 첫 번째 사람부터 시작
  cursor = head;
}

// k만큼 이동해서 출력
function printRes(n, k) {
  let count = n;

  while (count > 0) {
    // k-1번 이동
    for (let i = 0; i < k - 1; i++) {
      prev = cursor;
      cursor = cursor.next;
    }

    // 현재 cursor가 가리키는 노드를 결과에 추가
    res.push(cursor.data);

    // 노드 제거
    if (count === 1) {
      // 마지막 노드인 경우
      cursor = null;
    } else {
      // prev가 없는 경우 처리
      if (prev === null) {
        // 첫 번째부터 시작해서 cursor 이전 노드 찾기
        let temp = cursor;
        while (temp.next !== cursor) {
          temp = temp.next;
        }
        prev = temp;
      }

      // 노드 제거
      prev.next = cursor.next;
      cursor = cursor.next;
      prev = null; // 다음 반복을 위해 초기화
    }

    count--;
  }
}

rl.on('line', (line) => {
  const [n, k] = line.split(' ').map(Number);

  // n만큼의 원형 리스트 배열 생성
  initCircle(n);
  // pointer를 k만큼 이동하면서 원형 리스트가 null이 될 때 까지 진행
  printRes(n, k);
  rl.close();
}).on('close', () => {
  console.log(`<${res.join(', ')}>`);
  process.exit();
});
```

#### 💭 배운 점

- 큐로도 풀 수 있는데 이번 0x04가 연결 리스트라 연결 리스트로 풀어봄

---

## 📈 이번 주차 복기

### 🔄 이전 주차 대비 개선점

### 📚 학습한 새로운 개념

# ⏱️ JavaScript 시간 복잡도 판단 가이드

## 🧮 JavaScript 기본 계산 공식

### JavaScript는 다른 언어보다 느림!

```
C/C++: 1초 = 약 1억 (10^8) 연산
Python: 1초 = 약 2천만 (2×10^7) 연산
JavaScript: 1초 = 약 5천만 (5×10^7) 연산 ⚠️

보수적 JavaScript 기준: 1초 = 약 1천만 (10^7) 연산
```

### JavaScript 시간 제한별 최대 연산 수

- **0.1초**: 500만 연산 (5×10^6)
- **0.3초**: 1500만 연산 (1.5×10^7)
- **1초**: 5천만 연산 (5×10^7)
- **2초**: 1억 연산 (10^8)

---

## 📊 JavaScript 입력 크기별 적절한 알고리즘

### N ≤ 8 → 지수/팩토리얼 가능

- O(N!) - 완전탐색 (8! = 40,320)
- O(2^N) - 비트마스킹 (2^8 = 256)

### N ≤ 15 → 지수 시간만

- O(2^N) - 비트마스킹 (2^15 = 32,768)
- **O(N!)는 위험** (15! = 1조)

### N ≤ 20 → 지수 시간 (조심)

- O(2^N) - 비트마스킹 (2^20 = 100만)
- **JavaScript에서는 경계선**

### N ≤ 50 → 3차 시간

- O(N^3) - 플로이드 워셜 (50^3 = 125,000)

### N ≤ 500 → 2차 시간

- O(N^2) - 2중 반복문 (500^2 = 25만)

### N ≤ 5,000 → 2차 시간 (조심)

- O(N^2) - 5000^2 = 2500만 (경계선)

### N ≤ 50,000 → 선형로그 시간만

- O(N log N) - 정렬 (50,000 × 16 ≈ 80만)
- **O(N^2)는 100% 시간 초과!** (50,000^2 = 25억)

### N ≤ 500,000 → 선형 시간

- O(N) - 단순 순회 (50만)
- O(N log N) - 정렬 (50만 × 19 ≈ 950만)

### N ≤ 1,000,000 → 선형 시간만

- O(N) - 단순 순회만 가능 (100만)

---

## 🚨 JavaScript 위험 신호 체크리스트

### 즉시 시간 초과 예상되는 경우

```
❌ N=50,000 이상 + 2중 반복문
❌ N=500,000 + O(N log N) 이상
❌ M=100,000 + 각 연산이 O(N)
❌ 시간 제한 1초 미만 + 복잡한 알고리즘
❌ 배열 메서드 중첩 사용 (filter + map + sort 등)
```

### JavaScript 특별 주의사항

```
⚠️ 문자열 연산이 많은 경우 더 느림
⚠️ 객체/배열 깊은 복사 연산
⚠️ 정규식 사용시 추가 오버헤드
⚠️ parseFloat, parseInt 남용
⚠️ 배열 메서드 체이닝 (.filter().map().reduce())
```

---

## 🎯 JavaScript 실전 판단 방법

### 1단계: 보수적으로 계산

```javascript
// JavaScript는 더 보수적으로!
const MAX_OPS_PER_SEC = 10 ** 7; // 1천만 (안전한 기준)

const timeLimit = 1; // 초
const maxOperations = timeLimit * MAX_OPS_PER_SEC;
```

### 2단계: 예상 연산 수 계산

```javascript
const N = 100000;
const M = 500000;

// 배열 접근법
const arrayOps = N * M; // 500억 연산
console.log(arrayOps > maxOperations); // true (시간 초과!)

// 연결리스트 접근법
const linkedListOps = M; // 50만 연산
console.log(linkedListOps < maxOperations); // true (통과!)
```

### 3단계: JavaScript 특수 상황 고려

```javascript
// 문자열 조작이 많은 경우
if (stringOperations > N * 1000) {
  console.log('문자열 연산 오버헤드 고려 필요');
}

// 배열 메서드 체이닝
const result = arr
  .filter((x) => x > 0) // O(N)
  .map((x) => x * 2) // O(N)
  .sort((a, b) => a - b); // O(N log N)
// 총 O(N log N) + 추가 오버헤드
```

---

## 🔍 JavaScript 실제 사례 분석

### 에디터 문제 - JavaScript 기준

```javascript
// 주어진 조건
const N = 100000; // 초기 문자열
const M = 500000; // 명령어 수
const timeLimit = 0.3; // 초

// 배열 접근법
const arrayOperations = M * N; // 500억
const maxOps = timeLimit * 10 ** 7; // 300만
console.log(`${arrayOperations} >> ${maxOps}`); // 500억 >> 300만 (절망적!)

// 연결리스트 접근법
const linkedOperations = M; // 50만
console.log(`${linkedOperations} << ${maxOps}`); // 50만 << 300만 (여유!)
```

### 일반적인 실수 사례들

```javascript
// ❌ 시간 초과 위험한 코드들
const N = 100000;

// Case 1: 2중 반복문
for (let i = 0; i < N; i++) {
  for (let j = 0; j < N; j++) {
    // 100억 연산 = 1000초!
  }
}

// Case 2: 배열 메서드 남용
for (let i = 0; i < N; i++) {
  arr.filter((x) => x > i).map((x) => x * 2); // N × N log N
}

// Case 3: 문자열 연결 반복
let str = '';
for (let i = 0; i < N; i++) {
  str += 'a'; // O(N^2) - 매번 새 문자열 생성!
}
```

---

## 💡 JavaScript 최적화 팁

### 빠른 입출력 처리

- 지금 readline으로 푸는데 fs로 바꿔야하나?

```javascript
// ❌ 느린 방법
const readline = require('readline');
// 매번 이벤트 처리로 오버헤드

// ✅ 빠른 방법
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
```

### 배열 연산 최적화

```javascript
// ❌ 느린 방법
arr.push(...newItems); // 스프레드 연산자 오버헤드

// ✅ 빠른 방법
for (const item of newItems) {
  arr.push(item);
}
```

### 문자열 처리 최적화

```javascript
// ❌ 느린 방법 - O(N^2)
let result = '';
for (let i = 0; i < N; i++) {
  result += chars[i];
}

// ✅ 빠른 방법 - O(N)
const result = chars.join('');
```

---

## 🎯 JavaScript 핵심 기준값

### 암기할 공식

```javascript
// 보수적 JavaScript 기준
예상연산수 ≤ 시간제한(초) × 10^7

// 위험 구간
N ≥ 50,000 && O(N^2) → 즉시 포기
M × N ≥ 10^8 → 확실한 시간 초과
시간제한 < 1초 → 매우 보수적 판단
```

### 자주 나오는 안전 기준

```javascript
N ≤ 1,000 → O(N^2) 안전
N ≤ 10,000 → O(N^2) 위험
N ≤ 100,000 → O(N log N) 까지
N ≤ 1,000,000 → O(N) 만
```

---
